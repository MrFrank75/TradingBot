using Binance.Common;
using Binance.Spot.Models;
using static System.Net.WebRequestMethods;

namespace TradingBot.BinanceServices
{
    public class FutureMarket : BinanceService
    {
        //This constructor uses the "production" web api address as explained here: https://binance-docs.github.io/apidocs/futures/en/#diff-book-depth-streams
        public FutureMarket(string baseUrl = "https://fapi.binance.com", string apiKey = null, string apiSecret = null)
:       base(new HttpClient(), baseUrl: baseUrl, apiKey: apiKey, apiSecret: apiSecret)
        {
        }


        private const string NEW_ORDER = "/fapi/v1/order";

        /// <summary>
        /// Send in a new order.<para />
        /// - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker.<para />
        /// - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached.<para />
        /// - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`.<para />
        /// - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`.<para />
        /// - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price.<para />
        /// - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`.<para />
        /// - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`.<para />
        /// - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.<para />
        /// Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:.<para />
        /// - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL`.<para />
        /// - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`.<para />
        /// Weight(IP): 1.
        /// </summary>
        /// <param name="symbol">Trading symbol, e.g. BNBUSDT.</param>
        /// <param name="side"></param>
        /// <param name="type">Order type.</param>
        /// <param name="timeInForce">Order time in force.</param>
        /// <param name="quantity">Order quantity.</param>
        /// <param name="quoteOrderQty">Quote quantity.</param>
        /// <param name="price">Order price.</param>
        /// <param name="newClientOrderId">Used to uniquely identify this cancel. Automatically generated by default.</param>
        /// <param name="strategyId">Identify an order as part of a strategy.</param>
        /// <param name="strategyType">The value cannot be less than 1000000.</param>
        /// <param name="stopPrice">Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.</param>
        /// <param name="trailingDelta">Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.</param>
        /// <param name="icebergQty">Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.</param>
        /// <param name="newOrderRespType">Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.</param>
        /// <param name="recvWindow">The value cannot be greater than 60000.</param>
        /// <returns>Order result.</returns>
        public async Task<string> NewOrder(string symbol, Side side, OrderType type, TimeInForce? timeInForce = null, decimal? quantity = null, decimal? quoteOrderQty = null, decimal? price = null, string newClientOrderId = null, int? strategyId = null, int? strategyType = null, decimal? stopPrice = null, decimal? trailingDelta = null, decimal? icebergQty = null, NewOrderResponseType? newOrderRespType = null, long? recvWindow = null)
        {
            var result = await this.SendSignedAsync<string>(
                NEW_ORDER,
                HttpMethod.Post,
                query: new Dictionary<string, object>
                {
                    { "symbol", symbol },
                    { "side", side },
                    { "type", type },
                    { "timeInForce", timeInForce },
                    { "quantity", quantity },
                    { "quoteOrderQty", quoteOrderQty },
                    { "price", price },
                    { "newClientOrderId", newClientOrderId },
                    { "strategyId", strategyId },
                    { "strategyType", strategyType },
                    { "stopPrice", stopPrice },
                    { "trailingDelta", trailingDelta },
                    { "icebergQty", icebergQty },
                    { "newOrderRespType", newOrderRespType },
                    { "recvWindow", recvWindow },
                    { "timestamp", DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() },
                });

            return result;
        }


        private const string CURRENT_OPEN_ORDERS = "/fapi/v1/openOrders";

        /// <summary>
        /// Get all open orders on a symbol. Careful when accessing this with no symbol.<para />
        /// Weight(IP):.<para />
        /// - `3` for a single symbol;.<para />
        /// - `40` when the symbol parameter is omitted;.
        /// </summary>
        /// <param name="symbol">Trading symbol, e.g. BNBUSDT.</param>
        /// <param name="recvWindow">The value cannot be greater than 60000.</param>
        /// <returns>Current open orders.</returns>
        public async Task<string> CurrentOpenOrders(string symbol = null, long? recvWindow = null)
        {
            var result = await this.SendSignedAsync<string>(
                CURRENT_OPEN_ORDERS,
                HttpMethod.Get,
                query: new Dictionary<string, object>
                {
                    { "symbol", symbol },
                    { "recvWindow", recvWindow },
                    { "timestamp", DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() },
                });

            return result;
        }


        private const string ORDER_BOOK = "/fapi/v1/depth";

        /// <summary>
        /// | Limit               | Weight(IP)  |.<para />
        /// |---------------------|-------------|.<para />
        /// | 1-100               | 1           |.<para />
        /// | 101-500             | 5           |.<para />
        /// | 501-1000            | 10          |.<para />
        /// | 1001-5000           | 50          |.
        /// </summary>
        /// <param name="symbol">Trading symbol, e.g. BNBUSDT.</param>
        /// <param name="limit">If limit > 5000, then the response will truncate to 5000.</param>
        /// <returns>Order book.</returns>
        public async Task<string> GetOrderBookSnapshot(string symbol, int? limit = null)
        {
            var result = await this.SendPublicAsync<string>(
                ORDER_BOOK,
                HttpMethod.Get,
                query: new Dictionary<string, object>
                {
                    { "symbol", symbol },
                    { "limit", limit },
                });

            return result;
        }

        private const string SYMBOL_PRICE_TICKER = "/fapi/v1/ticker/price";
        public async Task<string> GetSymbolPriceTicker(string symbol)
        {
            var result = await this.SendPublicAsync<string>(
                SYMBOL_PRICE_TICKER,
                HttpMethod.Get,
                query: new Dictionary<string, object>
                {
                    { "symbol", symbol }
                });

            return result;
        }
    }
}
